/* automatically generated by rust-bindgen 0.57.0 */
#![allow(non_camel_case_types)]

use alloc::format;
use alloc::string::String;
use alloc::vec::Vec;
use core::ptr;

use x86::current::paging::{PAddr, VAddr};

use crate::pci::{DmaObject, KERNEL_BASE};
use crate::reg::{
    vmxnet3_rxcompdesc, vmxnet3_rxdesc, vmxnet3_rxq_shared, vmxnet3_txcompdesc, vmxnet3_txdesc,
    vmxnet3_txq_shared, VMXNET3_INIT_GEN,
};
use crate::vmx::{QueueId, VMXNet3Error};
use crate::BoundedUSize;

pub type c_uint = u32;
pub type c_int = i32;
pub type u_int = c_uint;

pub const ETHER_ADDR_LEN: u32 = 6;

pub const VMXNET3_DEF_RX_QUEUES: u32 = 8;
pub const VMXNET3_DEF_TX_QUEUES: u32 = 8;
pub const VMXNET3_RXRINGS_PERQ: u32 = 2;
pub const VMXNET3_DEF_TX_NDESC: usize = 512;
pub const VMXNET3_MAX_TX_NDESC: usize = 4096;
pub const VMXNET3_MIN_TX_NDESC: usize = 32;
pub const VMXNET3_MASK_TX_NDESC: usize = 31;
pub const VMXNET3_DEF_RX_NDESC: usize = 512;
pub const VMXNET3_MAX_RX_NDESC: usize = 2048;
pub const VMXNET3_MIN_RX_NDESC: usize = 32;
pub const VMXNET3_MASK_RX_NDESC: usize = 31;
pub const VMXNET3_MAX_TX_NCOMPDESC: usize = 4096;
pub const VMXNET3_MAX_RX_NCOMPDESC: usize = 4096;
pub const VMXNET3_FLAG_RSS: usize = 2;
pub const VMXNET3_FLAG_SOFT_RSS: usize = 4;
pub const VMXNET3_DRIVER_VERSION: u32 = 65536;
pub const VMXNET3_TX_MAXSEGS: usize = 32;
pub const VMXNET3_TX_MAXSEGSIZE: usize = 16383;
pub const VMXNET3_RX_MAXSEGSIZE: usize = 16383;
pub const VMXNET3_MULTICAST_MAX: usize = 32;

#[repr(C)]
#[derive(Default, Debug, Copy, Clone)]
pub struct iflib_dma_info {
    pub p: u8,
}

#[repr(C)]
#[derive(Default, Debug, Copy, Clone)]
pub struct if_irq {
    pub p: u8,
}

#[repr(C)]
#[derive(Default, Debug, Copy, Clone)]
pub struct devicet {
    pub p: u8,
}

pub type device_t = devicet;

#[repr(C)]
#[derive(Default, Debug, Copy, Clone)]
pub struct if_ctx {
    pub p: u8,
}

pub type if_ctx_t = if_ctx;

#[repr(C)]
#[derive(Default, Debug, Copy, Clone)]
pub struct if_shared_ctx {
    pub p: u8,
}

pub type if_shared_ctx_t = if_shared_ctx;

#[repr(C)]
#[derive(Default, Debug, Copy, Clone)]
pub struct if_softc_ctx {
    pub p: u8,
}

pub type if_softc_ctx_t = if_softc_ctx;

#[repr(C)]
#[derive(Default, Debug, Copy, Clone)]
pub struct bus_space_handle {
    pub p: u8,
}

pub type bus_space_handle_t = bus_space_handle;

#[repr(C)]
#[derive(Default, Debug, Copy, Clone)]
pub struct bus_space_tag {
    pub p: u8,
}

pub type bus_space_tag_t = bus_space_tag;
pub type bus_addr_t = u64;

#[repr(C)]
#[derive(Debug)]
pub struct vmxnet3_txring {
    pub vxtxr_next: u_int,
    //pub vxtxr_ndesc: u_int, TODO: is this save to remove?
    pub vxtxr_gen: c_int,
    pub vxtxr_txd: Vec<vmxnet3_txdesc>,
}

impl vmxnet3_txring {
    fn new(vxtxr_ndesc: usize) -> Result<Self, VMXNet3Error> {
        let vxtxr_ndesc =
            BoundedUSize::<VMXNET3_MIN_TX_NDESC, VMXNET3_MAX_TX_NDESC>::new(vxtxr_ndesc);

        let mut vxtxr_txd: Vec<vmxnet3_txdesc> = Vec::new();
        vxtxr_txd.try_reserve_exact(*vxtxr_ndesc)?;

        for i in 0..*vxtxr_ndesc {
            vxtxr_txd.push(vmxnet3_txdesc::default());
        }

        Ok(vmxnet3_txring {
            vxtxr_next: 0,
            vxtxr_gen: VMXNET3_INIT_GEN,
            vxtxr_txd,
        })
    }

    fn vxtxr_ndesc(&self) -> usize {
        self.vxtxr_txd.len()
    }
}

impl DmaObject for vmxnet3_txring {
    fn paddr(&self) -> PAddr {
        PAddr::from(self.vxtxr_txd.as_ptr() as u64 - KERNEL_BASE)
    }

    fn vaddr(&self) -> VAddr {
        VAddr::from(self.vxtxr_txd.as_ptr() as u64)
    }
}

#[repr(C)]
#[derive(Debug)]
pub struct vmxnet3_rxring {
    pub vxrxr_rxd: Vec<vmxnet3_rxdesc>,
    pub vxrxr_gen: c_int,
    pub vxrxr_desc_skips: u64,
    pub vxrxr_refill_start: u16,
}

impl vmxnet3_rxring {
    fn new(vxrxr_ndesc: usize) -> Result<Self, VMXNet3Error> {
        let vxrxr_ndesc =
            BoundedUSize::<VMXNET3_MIN_RX_NDESC, VMXNET3_MAX_RX_NDESC>::new(vxrxr_ndesc);

        let mut vxrxr_rxd: Vec<vmxnet3_rxdesc> = Vec::new();
        vxrxr_rxd.try_reserve_exact(*vxrxr_ndesc)?;
        for i in 0..*vxrxr_ndesc {
            vxrxr_rxd.push(vmxnet3_rxdesc::default());
        }

        Ok(vmxnet3_rxring {
            vxrxr_rxd,
            vxrxr_gen: VMXNET3_INIT_GEN,
            vxrxr_desc_skips: 0,
            vxrxr_refill_start: 0,
        })
    }

    fn vxrxr_ndesc(&self) -> usize {
        self.vxrxr_rxd.len()
    }
}

impl DmaObject for vmxnet3_rxring {
    fn paddr(&self) -> PAddr {
        PAddr::from(self.vxrxr_rxd.as_ptr() as u64 - KERNEL_BASE)
    }

    fn vaddr(&self) -> VAddr {
        VAddr::from(self.vxrxr_rxd.as_ptr() as u64)
    }
}

/// A vector of either Rx or Tx completion descriptors.
pub enum CompRingBuf {
    TxCd(Vec<vmxnet3_txcompdesc>),
    RxCd(Vec<vmxnet3_rxcompdesc>),
}

/// A completion ring that maintains some statistics about paket errors
/// and zero length packets encountered.
#[repr(C)]
pub struct vmxnet3_comp_ring {
    pub vxcr: CompRingBuf,
    pub vxcr_next: u_int,
    pub vxcr_gen: c_int,
    pub vxcr_zero_length: u64,
    pub vxcr_pkt_errors: u64,
}

impl vmxnet3_comp_ring {
    pub(crate) fn new_rx(ndesc: usize) -> Result<Self, VMXNet3Error> {
        let mut vxcr = Vec::new();
        vxcr.try_reserve_exact(ndesc)?;

        for i in 0..ndesc {
            vxcr.push(vmxnet3_rxcompdesc::default());
        }

        Ok(vmxnet3_comp_ring {
            vxcr: CompRingBuf::RxCd(vxcr),
            vxcr_next: 0,
            vxcr_gen: VMXNET3_INIT_GEN,
            vxcr_zero_length: 0,
            vxcr_pkt_errors: 0,
        })
    }

    pub(crate) fn new_tx(ndesc: usize) -> Result<Self, VMXNet3Error> {
        let mut vxcr = Vec::new();
        vxcr.try_reserve_exact(ndesc)?;
        for i in 0..ndesc {
            vxcr.push(vmxnet3_txcompdesc::default());
        }

        Ok(vmxnet3_comp_ring {
            vxcr: CompRingBuf::TxCd(vxcr),
            vxcr_next: 0,
            vxcr_gen: VMXNET3_INIT_GEN,
            vxcr_zero_length: 0,
            vxcr_pkt_errors: 0,
        })
    }

    pub fn vxcr_ndesc(&self) -> usize {
        match &self.vxcr {
            CompRingBuf::RxCd(buf) => buf.len(),
            CompRingBuf::TxCd(buf) => buf.len(),
        }
    }
}

impl DmaObject for vmxnet3_comp_ring {
    fn paddr(&self) -> PAddr {
        match &self.vxcr {
            CompRingBuf::RxCd(buf) => PAddr::from(buf.as_ptr() as u64 - KERNEL_BASE),
            CompRingBuf::TxCd(buf) => PAddr::from(buf.as_ptr() as u64 - KERNEL_BASE),
        }
    }

    fn vaddr(&self) -> VAddr {
        match &self.vxcr {
            CompRingBuf::RxCd(buf) => VAddr::from(buf.as_ptr() as u64),
            CompRingBuf::TxCd(buf) => VAddr::from(buf.as_ptr() as u64),
        }
    }
}

#[repr(C, align(64))]
pub struct TxQueue {
    pub vxtxq_id: QueueId,
    pub vxtxq_last_flush: c_int,
    pub vxtxq_intr_idx: c_int,
    pub vxtxq_cmd_ring: vmxnet3_txring,
    pub vxtxq_comp_ring: vmxnet3_comp_ring,
}

impl TxQueue {
    pub(crate) fn new(vxtxq_id: QueueId, ndesc: usize) -> Result<Self, VMXNet3Error> {
        // Enforce that the transmit completion queue descriptor count is
        // the same as the transmit command queue descriptor count.
        Ok(TxQueue {
            vxtxq_id,
            vxtxq_last_flush: -1,
            vxtxq_intr_idx: 0,
            vxtxq_cmd_ring: vmxnet3_txring::new(ndesc)?,
            vxtxq_comp_ring: vmxnet3_comp_ring::new_tx(ndesc)?,
        })
    }

    pub fn vxtxq_name(&self) -> String {
        match self.vxtxq_id {
            QueueId::Tx(id) => format!("tx-{}", id),
            _ => unreachable!("Impossible queue ID"),
        }
    }

    pub fn vxtxq_ts(&self) -> *mut vmxnet3_txq_shared {
        unimplemented!("get this through vmxnet3 struct?")
    }
}

impl DmaObject for TxQueue {}

#[repr(C, align(64))]
pub struct RxQueue {
    pub vxrxq_id: QueueId,
    pub vxrxq_intr_idx: c_int,
    pub vxrxq_irq: if_irq,
    pub vxrxq_cmd_ring: [vmxnet3_rxring; 2usize],
    pub vxrxq_comp_ring: vmxnet3_comp_ring,
}

impl RxQueue {
    pub(crate) fn new(vxrxq_id: QueueId, ndesc: usize) -> Result<Self, VMXNet3Error> {
        // Enforce that the receive completion queue descriptor count is the
        // sum of the receive command queue descriptor counts, and that the
        // second receive command queue descriptor count is the same as the
        // first one.
        Ok(RxQueue {
            vxrxq_id,
            vxrxq_intr_idx: 0,
            vxrxq_irq: Default::default(),
            vxrxq_cmd_ring: [vmxnet3_rxring::new(ndesc)?, vmxnet3_rxring::new(ndesc)?],
            vxrxq_comp_ring: vmxnet3_comp_ring::new_rx(2 * ndesc)?,
        })
    }

    pub fn vxrxq_name(&self) -> String {
        match self.vxrxq_id {
            QueueId::Rx(id) => format!("rx-{}", id),
            _ => unreachable!("Impossible queue ID"),
        }
    }

    pub fn vxrxq_rs(&self) -> *mut vmxnet3_rxq_shared {
        unimplemented!("get this through vmxnet3 struct?")
    }
}

impl DmaObject for RxQueue {}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct vmxnet3_softc {
    pub vmx_dev: device_t,
    pub vmx_ctx: if_ctx_t,
    pub vmx_sctx: if_shared_ctx_t,
    pub vmx_scctx: if_softc_ctx_t,
    pub vmx_ifp: *mut ifnet,
    pub vmx_ds: *mut vmxnet3_driver_shared,
    pub vmx_flags: u32,
    pub vmx_rxq: *mut RxQueue,
    pub vmx_txq: *mut TxQueue,
    pub vmx_res0: *mut resource,
    pub vmx_iot0: bus_space_tag_t,
    pub vmx_ioh0: bus_space_handle_t,
    pub vmx_res1: *mut resource,
    pub vmx_iot1: bus_space_tag_t,
    pub vmx_ioh1: bus_space_handle_t,
    pub vmx_link_active: c_int,
    pub vmx_intr_mask_mode: c_int,
    pub vmx_event_intr_idx: c_int,
    pub vmx_event_intr_irq: if_irq,
    pub vmx_mcast: *mut u8,
    pub vmx_rss: *mut vmxnet3_rss_shared,
    pub vmx_ds_dma: iflib_dma_info,
    pub vmx_qs_dma: iflib_dma_info,
    pub vmx_mcast_dma: iflib_dma_info,
    pub vmx_rss_dma: iflib_dma_info,
    pub vmx_media: *mut ifmedia,
    pub vmx_vlan_filter: [u32; 128usize],
    pub vmx_lladdr: [u8; 6usize],
}

impl Default for vmxnet3_softc {
    fn default() -> Self {
        vmxnet3_softc {
            vmx_dev: Default::default(),
            vmx_ctx: Default::default(),
            vmx_sctx: Default::default(),
            vmx_scctx: Default::default(),
            vmx_ifp: ptr::null_mut(),
            vmx_ds: ptr::null_mut(),
            vmx_flags: 0,
            vmx_rxq: ptr::null_mut(),
            vmx_txq: ptr::null_mut(),
            vmx_res0: ptr::null_mut(),
            vmx_iot0: Default::default(),
            vmx_ioh0: Default::default(),
            vmx_res1: ptr::null_mut(),
            vmx_iot1: Default::default(),
            vmx_ioh1: Default::default(),
            vmx_link_active: 0,
            vmx_intr_mask_mode: 0,
            vmx_event_intr_idx: 0,
            vmx_event_intr_irq: Default::default(),
            vmx_mcast: ptr::null_mut(),
            vmx_rss: ptr::null_mut(),
            vmx_ds_dma: Default::default(),
            vmx_qs_dma: Default::default(),
            vmx_mcast_dma: Default::default(),
            vmx_rss_dma: Default::default(),
            vmx_media: ptr::null_mut(),
            vmx_vlan_filter: [0; 128usize],
            vmx_lladdr: [0; 6usize],
        }
    }
}

#[repr(C)]
#[derive(Default, Debug, Copy, Clone)]
pub struct sysctl_oid_list {
    pub _address: u8,
}

#[repr(C)]
#[derive(Default, Debug, Copy, Clone)]
pub struct ifnet {
    pub _address: u8,
}

#[repr(C)]
#[derive(Default, Debug, Copy, Clone)]
pub struct vmxnet3_driver_shared {
    pub _address: u8,
}

#[repr(C)]
#[derive(Default, Debug, Copy, Clone)]
pub struct resource {
    pub _address: u8,
}

#[repr(C)]
#[derive(Default, Debug, Copy, Clone)]
pub struct vmxnet3_rss_shared {
    pub _address: u8,
}

#[repr(C)]
#[derive(Default, Debug, Copy, Clone)]
pub struct ifmedia {
    pub _address: u8,
}
