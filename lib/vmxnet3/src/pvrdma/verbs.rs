// Copyright Â© 2021 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: BSD-2-Clause

//! IB verbs API for pvrdma.

/* originally generated by rust-bindgen 0.58.1 from pvrdma_verbs.h in Linux v5.12 */

#![allow(non_camel_case_types)]

use super::pvrdma::{be16, be32, be64};

#[repr(C)]
#[derive(Copy, Clone)]
pub union pvrdma_gid {
    pub raw: [u8; 16usize],
    pub global: pvrdma_gid__bindgen_ty_1,
}

#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct pvrdma_gid__bindgen_ty_1 {
    pub subnet_prefix: be64,
    pub interface_id: be64,
}

impl Default for pvrdma_gid {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_link_layer {
    PVRDMA_LINK_LAYER_UNSPECIFIED = 0,
    PVRDMA_LINK_LAYER_INFINIBAND = 1,
    PVRDMA_LINK_LAYER_ETHERNET = 2,
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_mtu {
    PVRDMA_MTU_256 = 1,
    PVRDMA_MTU_512 = 2,
    PVRDMA_MTU_1024 = 3,
    PVRDMA_MTU_2048 = 4,
    PVRDMA_MTU_4096 = 5,
}

impl pvrdma_mtu {
    fn from(mtu: u32) -> pvrdma_mtu {
        match mtu {
            256 => pvrdma_mtu::PVRDMA_MTU_256,
            512 => pvrdma_mtu::PVRDMA_MTU_512,
            1024 => pvrdma_mtu::PVRDMA_MTU_1024,
            2048 => pvrdma_mtu::PVRDMA_MTU_2048,
            4096 => pvrdma_mtu::PVRDMA_MTU_4096,
            _ => unreachable!("invalid MTU size"),
        }
    }

    fn to_int(self) -> u32 {
        match self {
            pvrdma_mtu::PVRDMA_MTU_256 => 256,
            pvrdma_mtu::PVRDMA_MTU_512 => 512,
            pvrdma_mtu::PVRDMA_MTU_1024 => 1024,
            pvrdma_mtu::PVRDMA_MTU_2048 => 2048,
            pvrdma_mtu::PVRDMA_MTU_4096 => 4096,
        }
    }
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_port_state {
    PVRDMA_PORT_NOP = 0,
    PVRDMA_PORT_DOWN = 1,
    PVRDMA_PORT_INIT = 2,
    PVRDMA_PORT_ARMED = 3,
    PVRDMA_PORT_ACTIVE = 4,
    PVRDMA_PORT_ACTIVE_DEFER = 5,
}

impl pvrdma_port_cap_flags {
    pub const PVRDMA_PORT_CAP_FLAGS_MAX: pvrdma_port_cap_flags =
        pvrdma_port_cap_flags::PVRDMA_PORT_IP_BASED_GIDS;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_port_cap_flags {
    PVRDMA_PORT_SM = 2,
    PVRDMA_PORT_NOTICE_SUP = 4,
    PVRDMA_PORT_TRAP_SUP = 8,
    PVRDMA_PORT_OPT_IPD_SUP = 16,
    PVRDMA_PORT_AUTO_MIGR_SUP = 32,
    PVRDMA_PORT_SL_MAP_SUP = 64,
    PVRDMA_PORT_MKEY_NVRAM = 128,
    PVRDMA_PORT_PKEY_NVRAM = 256,
    PVRDMA_PORT_LED_INFO_SUP = 512,
    PVRDMA_PORT_SM_DISABLED = 1024,
    PVRDMA_PORT_SYS_IMAGE_GUID_SUP = 2048,
    PVRDMA_PORT_PKEY_SW_EXT_PORT_TRAP_SUP = 4096,
    PVRDMA_PORT_EXTENDED_SPEEDS_SUP = 16384,
    PVRDMA_PORT_CM_SUP = 65536,
    PVRDMA_PORT_SNMP_TUNNEL_SUP = 131072,
    PVRDMA_PORT_REINIT_SUP = 262144,
    PVRDMA_PORT_DEVICE_MGMT_SUP = 524288,
    PVRDMA_PORT_VENDOR_CLASS_SUP = 1048576,
    PVRDMA_PORT_DR_NOTICE_SUP = 2097152,
    PVRDMA_PORT_CAP_MASK_NOTICE_SUP = 4194304,
    PVRDMA_PORT_BOOT_MGMT_SUP = 8388608,
    PVRDMA_PORT_LINK_LATENCY_SUP = 16777216,
    PVRDMA_PORT_CLIENT_REG_SUP = 33554432,
    PVRDMA_PORT_IP_BASED_GIDS = 67108864,
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_port_width {
    PVRDMA_WIDTH_1X = 1,
    PVRDMA_WIDTH_4X = 2,
    PVRDMA_WIDTH_8X = 4,
    PVRDMA_WIDTH_12X = 8,
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_port_speed {
    PVRDMA_SPEED_SDR = 1,
    PVRDMA_SPEED_DDR = 2,
    PVRDMA_SPEED_QDR = 4,
    PVRDMA_SPEED_FDR10 = 8,
    PVRDMA_SPEED_FDR = 16,
    PVRDMA_SPEED_EDR = 32,
}

#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct pvrdma_port_attr {
    pub state: pvrdma_port_state,
    pub max_mtu: pvrdma_mtu,
    pub active_mtu: pvrdma_mtu,
    pub gid_tbl_len: u32,
    pub port_cap_flags: u32,
    pub max_msg_sz: u32,
    pub bad_pkey_cntr: u32,
    pub qkey_viol_cntr: u32,
    pub pkey_tbl_len: u16,
    pub lid: u16,
    pub sm_lid: u16,
    pub lmc: u8,
    pub max_vl_num: u8,
    pub sm_sl: u8,
    pub subnet_timeout: u8,
    pub init_type_reply: u8,
    pub active_width: u8,
    pub active_speed: u8,
    pub phys_state: u8,
    pub reserved: [u8; 2usize],
}

impl Default for pvrdma_port_attr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pvrdma_global_route {
    pub dgid: pvrdma_gid,
    pub flow_label: u32,
    pub sgid_index: u8,
    pub hop_limit: u8,
    pub traffic_class: u8,
    pub reserved: u8,
}

impl Default for pvrdma_global_route {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pvrdma_grh {
    pub version_tclass_flow: be32,
    pub paylen: be16,
    pub next_hdr: u8,
    pub hop_limit: u8,
    pub sgid: pvrdma_gid,
    pub dgid: pvrdma_gid,
}

impl Default for pvrdma_grh {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_ah_flags {
    PVRDMA_AH_GRH = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_rate {
    PVRDMA_RATE_PORT_CURRENT = 0,
    PVRDMA_RATE_2_5_GBPS = 2,
    PVRDMA_RATE_5_GBPS = 5,
    PVRDMA_RATE_10_GBPS = 3,
    PVRDMA_RATE_20_GBPS = 6,
    PVRDMA_RATE_30_GBPS = 4,
    PVRDMA_RATE_40_GBPS = 7,
    PVRDMA_RATE_60_GBPS = 8,
    PVRDMA_RATE_80_GBPS = 9,
    PVRDMA_RATE_120_GBPS = 10,
    PVRDMA_RATE_14_GBPS = 11,
    PVRDMA_RATE_56_GBPS = 12,
    PVRDMA_RATE_112_GBPS = 13,
    PVRDMA_RATE_168_GBPS = 14,
    PVRDMA_RATE_25_GBPS = 15,
    PVRDMA_RATE_100_GBPS = 16,
    PVRDMA_RATE_200_GBPS = 17,
    PVRDMA_RATE_300_GBPS = 18,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pvrdma_ah_attr {
    pub grh: pvrdma_global_route,
    pub dlid: u16,
    pub vlan_id: u16,
    pub sl: u8,
    pub src_path_bits: u8,
    pub static_rate: u8,
    pub ah_flags: u8,
    pub port_num: u8,
    pub dmac: [u8; 6usize],
    pub reserved: u8,
}

impl Default for pvrdma_ah_attr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_cq_notify_flags {
    PVRDMA_CQ_SOLICITED = 1,
    PVRDMA_CQ_NEXT_COMP = 2,
    PVRDMA_CQ_SOLICITED_MASK = 3,
    PVRDMA_CQ_REPORT_MISSED_EVENTS = 4,
}

#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct pvrdma_qp_cap {
    pub max_send_wr: u32,
    pub max_recv_wr: u32,
    pub max_send_sge: u32,
    pub max_recv_sge: u32,
    pub max_inline_data: u32,
    pub reserved: u32,
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_sig_type {
    PVRDMA_SIGNAL_ALL_WR = 0,
    PVRDMA_SIGNAL_REQ_WR = 1,
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_qp_type {
    PVRDMA_QPT_SMI = 0,
    PVRDMA_QPT_GSI = 1,
    PVRDMA_QPT_RC = 2,
    PVRDMA_QPT_UC = 3,
    PVRDMA_QPT_UD = 4,
    PVRDMA_QPT_RAW_IPV6 = 5,
    PVRDMA_QPT_RAW_ETHERTYPE = 6,
    PVRDMA_QPT_RAW_PACKET = 8,
    PVRDMA_QPT_XRC_INI = 9,
    PVRDMA_QPT_XRC_TGT = 10,
    PVRDMA_QPT_MAX = 11,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_qp_create_flags {
    PVRDMA_QP_CREATE_IPOPVRDMA_UD_LSO = 1,
    PVRDMA_QP_CREATE_BLOCK_MULTICAST_LOOPBACK = 2,
}
impl pvrdma_qp_attr_mask {
    pub const PVRDMA_QP_ATTR_MASK_MAX: pvrdma_qp_attr_mask =
        pvrdma_qp_attr_mask::PVRDMA_QP_DEST_QPN;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_qp_attr_mask {
    PVRDMA_QP_STATE = 1,
    PVRDMA_QP_CUR_STATE = 2,
    PVRDMA_QP_EN_SQD_ASYNC_NOTIFY = 4,
    PVRDMA_QP_ACCESS_FLAGS = 8,
    PVRDMA_QP_PKEY_INDEX = 16,
    PVRDMA_QP_PORT = 32,
    PVRDMA_QP_QKEY = 64,
    PVRDMA_QP_AV = 128,
    PVRDMA_QP_PATH_MTU = 256,
    PVRDMA_QP_TIMEOUT = 512,
    PVRDMA_QP_RETRY_CNT = 1024,
    PVRDMA_QP_RNR_RETRY = 2048,
    PVRDMA_QP_RQ_PSN = 4096,
    PVRDMA_QP_MAX_QP_RD_ATOMIC = 8192,
    PVRDMA_QP_ALT_PATH = 16384,
    PVRDMA_QP_MIN_RNR_TIMER = 32768,
    PVRDMA_QP_SQ_PSN = 65536,
    PVRDMA_QP_MAX_DEST_RD_ATOMIC = 131072,
    PVRDMA_QP_PATH_MIG_STATE = 262144,
    PVRDMA_QP_CAP = 524288,
    PVRDMA_QP_DEST_QPN = 1048576,
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_qp_state {
    PVRDMA_QPS_RESET = 0,
    PVRDMA_QPS_INIT = 1,
    PVRDMA_QPS_RTR = 2,
    PVRDMA_QPS_RTS = 3,
    PVRDMA_QPS_SQD = 4,
    PVRDMA_QPS_SQE = 5,
    PVRDMA_QPS_ERR = 6,
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_mig_state {
    PVRDMA_MIG_MIGRATED = 0,
    PVRDMA_MIG_REARM = 1,
    PVRDMA_MIG_ARMED = 2,
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_mw_type {
    PVRDMA_MW_TYPE_1 = 1,
    PVRDMA_MW_TYPE_2 = 2,
}

#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct pvrdma_srq_attr {
    pub max_wr: u32,
    pub max_sge: u32,
    pub srq_limit: u32,
    pub reserved: u32,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pvrdma_qp_attr {
    pub qp_state: pvrdma_qp_state,
    pub cur_qp_state: pvrdma_qp_state,
    pub path_mtu: pvrdma_mtu,
    pub path_mig_state: pvrdma_mig_state,
    pub qkey: u32,
    pub rq_psn: u32,
    pub sq_psn: u32,
    pub dest_qp_num: u32,
    pub qp_access_flags: u32,
    pub pkey_index: u16,
    pub alt_pkey_index: u16,
    pub en_sqd_async_notify: u8,
    pub sq_draining: u8,
    pub max_rd_atomic: u8,
    pub max_dest_rd_atomic: u8,
    pub min_rnr_timer: u8,
    pub port_num: u8,
    pub timeout: u8,
    pub retry_cnt: u8,
    pub rnr_retry: u8,
    pub alt_port_num: u8,
    pub alt_timeout: u8,
    pub reserved: [u8; 5usize],
    pub cap: pvrdma_qp_cap,
    pub ah_attr: pvrdma_ah_attr,
    pub alt_ah_attr: pvrdma_ah_attr,
}

impl Default for pvrdma_qp_attr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl pvrdma_send_flags {
    pub const PVRDMA_SEND_FLAGS_MAX: pvrdma_send_flags = pvrdma_send_flags::PVRDMA_SEND_IP_CSUM;
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_send_flags {
    PVRDMA_SEND_FENCE = 1,
    PVRDMA_SEND_SIGNALED = 2,
    PVRDMA_SEND_SOLICITED = 4,
    PVRDMA_SEND_INLINE = 8,
    PVRDMA_SEND_IP_CSUM = 16,
}

impl pvrdma_access_flags {
    pub const PVRDMA_ACCESS_FLAGS_MAX: pvrdma_access_flags =
        pvrdma_access_flags::PVRDMA_ACCESS_ON_DEMAND;
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pvrdma_access_flags {
    PVRDMA_ACCESS_LOCAL_WRITE = 1,
    PVRDMA_ACCESS_REMOTE_WRITE = 2,
    PVRDMA_ACCESS_REMOTE_READ = 4,
    PVRDMA_ACCESS_REMOTE_ATOMIC = 8,
    PVRDMA_ACCESS_MW_BIND = 16,
    PVRDMA_ZERO_BASED = 32,
    PVRDMA_ACCESS_ON_DEMAND = 64,
}
